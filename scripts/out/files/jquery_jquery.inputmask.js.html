<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>jquery&#x2F;jquery.inputmask.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: jquery&#x2F;jquery.inputmask.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
* @license Input Mask plugin for jquery
* http:&#x2F;&#x2F;github.com&#x2F;RobinHerbots&#x2F;jquery.inputmask
* Copyright (c) 2010 - 2012 Robin Herbots
* Licensed under the MIT license (http:&#x2F;&#x2F;www.opensource.org&#x2F;licenses&#x2F;mit-license.php)
* Version: 1.0.24
*&#x2F;

(function ($) {
    if ($.fn.inputmask == undefined) {
        $.inputmask = {
            &#x2F;&#x2F;options default
            defaults: {
                placeholder: &quot;_&quot;,
                optionalmarker: {
                    start: &quot;[&quot;,
                    end: &quot;]&quot;
                },
                escapeChar: &quot;\\&quot;,
                mask: null,
                oncomplete: null, &#x2F;&#x2F;executes when the mask is complete
                onincomplete: null, &#x2F;&#x2F;executes when the mask is incomplete and focus is lost
                oncleared: null, &#x2F;&#x2F;executes when the mask is cleared
                repeat: 0, &#x2F;&#x2F;repetitions of the mask
                greedy: true, &#x2F;&#x2F;true: allocated buffer for the mask and repetitions - false: allocate only if needed
                autoUnmask: false, &#x2F;&#x2F;automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor
                clearMaskOnLostFocus: true,
                insertMode: true, &#x2F;&#x2F;insert the input or overwrite the input
                clearIncomplete: false, &#x2F;&#x2F;clear the incomplete input on blur
                aliases: {}, &#x2F;&#x2F;aliases definitions =&gt; see jquery.inputmask.extensions.js
                onKeyUp: $.noop, &#x2F;&#x2F;override to implement autocomplete on certain keys for example
                onKeyDown: $.noop, &#x2F;&#x2F;override to implement autocomplete on certain keys for example
                &#x2F;&#x2F;numeric basic properties
                numericInput: false, &#x2F;&#x2F;numericInput input direction style (input shifts to the left while holding the caret position)
                radixPoint: &quot;.&quot;, &#x2F;&#x2F; | &quot;,&quot;
                &#x2F;&#x2F;numeric basic properties
                definitions: {
                    &#x27;9&#x27;: {
                        validator: &quot;[0-9]&quot;,
                        cardinality: 1
                    },
                    &#x27;a&#x27;: {
                        validator: &quot;[A-Za-z\u0410-\u044F\u0401\u0451]&quot;,
                        cardinality: 1
                    },
                    &#x27;*&#x27;: {
                        validator: &quot;[A-Za-z\u0410-\u044F\u0401\u04510-9]&quot;,
                        cardinality: 1
                    }
                },
                keyCode: { ALT: 18, BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108,
                    NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91
                },
                ignorables: [8, 9, 13, 16, 17, 18, 20, 27, 33, 34, 35, 36, 37, 38, 39, 40, 46, 91, 93, 108]
            },
            val: $.fn.val &#x2F;&#x2F;store the original jquery val function
        };

        $.fn.inputmask = function (fn, options) {
            var opts = $.extend(true, {}, $.inputmask.defaults, options);
            var pasteEvent = isInputEventSupported(&#x27;paste&#x27;) ? &#x27;paste&#x27; : &#x27;input&#x27;;

            var iphone = navigator.userAgent.match(&#x2F;iphone&#x2F;i) != null;
            var android = navigator.userAgent.match(&#x2F;android.*mobile safari.*&#x2F;i) != null;
            if (android) {
                var browser = navigator.userAgent.match(&#x2F;mobile safari.*&#x2F;i);
                var version = parseInt(new RegExp(&#x2F;[0-9]+&#x2F;).exec(browser));
                android = version &lt;= 533;
            }
            var caretposCorrection = null;

            if (typeof fn == &quot;string&quot;) {
                switch (fn) {
                    case &quot;mask&quot;:
                        &#x2F;&#x2F;init buffer
                        var _buffer = getMaskTemplate();
                        var tests = getTestingChain();

                        return this.each(function () {
                            mask(this);
                        });
                        break;
                    case &quot;unmaskedvalue&quot;:
                        var tests = this.data(&#x27;inputmask&#x27;)[&#x27;tests&#x27;];
                        var _buffer = this.data(&#x27;inputmask&#x27;)[&#x27;_buffer&#x27;];
                        opts.greedy = this.data(&#x27;inputmask&#x27;)[&#x27;greedy&#x27;];
                        opts.repeat = this.data(&#x27;inputmask&#x27;)[&#x27;repeat&#x27;];
                        opts.definitions = this.data(&#x27;inputmask&#x27;)[&#x27;definitions&#x27;];
                        return unmaskedvalue(this);
                        break;
                    case &quot;remove&quot;:
                        var tests, _buffer;
                        return this.each(function () {
                            var $input = $(this), input = this;
                            setTimeout(function () {
                                if ($input.data(&#x27;inputmask&#x27;)) {
                                    tests = $input.data(&#x27;inputmask&#x27;)[&#x27;tests&#x27;];
                                    _buffer = $input.data(&#x27;inputmask&#x27;)[&#x27;_buffer&#x27;];
                                    opts.greedy = $input.data(&#x27;inputmask&#x27;)[&#x27;greedy&#x27;];
                                    opts.repeat = $input.data(&#x27;inputmask&#x27;)[&#x27;repeat&#x27;];
                                    opts.definitions = $input.data(&#x27;inputmask&#x27;)[&#x27;definitions&#x27;];
                                    &#x2F;&#x2F;writeout the unmaskedvalue
                                    input._valueSet(unmaskedvalue($input, true));
                                    &#x2F;&#x2F;clear data
                                    $input.removeData(&#x27;inputmask&#x27;);
                                    &#x2F;&#x2F;unbind all events
                                    $input.unbind(&quot;.inputmask&quot;);
                                    $input.removeClass(&#x27;focus.inputmask&#x27;);
                                    &#x2F;&#x2F;restore the value property
                                    var valueProperty;
                                    if (Object.getOwnPropertyDescriptor)
                                        valueProperty = Object.getOwnPropertyDescriptor(input, &quot;value&quot;);
                                    if (valueProperty &amp;&amp; valueProperty.get) {
                                        if (input._valueGet) {
                                            Object.defineProperty(input, &quot;value&quot;, {
                                                get: input._valueGet,
                                                set: input._valueSet
                                            });
                                        }
                                    } else if (document.__lookupGetter__ &amp;&amp; input.__lookupGetter__(&quot;value&quot;)) {
                                        if (input._valueGet) {
                                            input.__defineGetter__(&quot;value&quot;, input._valueGet);
                                            input.__defineSetter__(&quot;value&quot;, input._valueSet);
                                        }
                                    }
                                    delete input._valueGet;
                                    delete input._valueSet;
                                }
                            }, 0);
                        });
                        break;
                    case &quot;getemptymask&quot;: &#x2F;&#x2F;return the default (empty) mask value, usefull for setting the default value in validation
                        if (this.data(&#x27;inputmask&#x27;))
                            return this.data(&#x27;inputmask&#x27;)[&#x27;_buffer&#x27;].join(&#x27;&#x27;);
                        else return &quot;&quot;;
                    case &quot;hasMaskedValue&quot;: &#x2F;&#x2F;check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value 
                        return this.data(&#x27;inputmask&#x27;) ? !this.data(&#x27;inputmask&#x27;)[&#x27;autoUnmask&#x27;] : false;
                    default:
                        &#x2F;&#x2F;check if the fn is an alias
                        if (!resolveAlias(fn)) {
                            &#x2F;&#x2F;maybe fn is a mask so we try
                            &#x2F;&#x2F;set mask
                            opts.mask = fn;
                        }
                        &#x2F;&#x2F;init buffer
                        var _buffer = getMaskTemplate();
                        var tests = getTestingChain();

                        return this.each(function () {
                            mask(this);
                        });

                        break;
                }
            } if (typeof fn == &quot;object&quot;) {
                opts = $.extend(true, {}, $.inputmask.defaults, fn);
                resolveAlias(opts.alias); &#x2F;&#x2F;resolve aliases
                &#x2F;&#x2F;init buffer
                var _buffer = getMaskTemplate();
                var tests = getTestingChain();

                return this.each(function () {
                    mask(this);
                });
            }

            &#x2F;&#x2F;helper functions
            function isInputEventSupported(eventName) {
                var el = document.createElement(&#x27;input&#x27;),
		  eventName = &#x27;on&#x27; + eventName,
		  isSupported = (eventName in el);
                if (!isSupported) {
                    el.setAttribute(eventName, &#x27;return;&#x27;);
                    isSupported = typeof el[eventName] == &#x27;function&#x27;;
                }
                el = null;
                return isSupported;
            }

            function resolveAlias(aliasStr) {
                var aliasDefinition = opts.aliases[aliasStr];
                if (aliasDefinition) {
                    if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias); &#x2F;&#x2F;alias is another alias
                    $.extend(true, opts, aliasDefinition);  &#x2F;&#x2F;merge alias definition in the options
                    $.extend(true, opts, options);  &#x2F;&#x2F;reapply extra given options
                    return true;
                }
                return false;
            }

            function getMaskTemplate() {
                var escaped = false, outCount = 0;
                if (opts.mask.length == 1 &amp;&amp; opts.greedy == false) { opts.placeholder = &quot;&quot;; } &#x2F;&#x2F;hide placeholder with single non-greedy mask
                var singleMask = $.map(opts.mask.split(&quot;&quot;), function (element, index) {
                    var outElem = [];
                    if (element == opts.escapeChar) {
                        escaped = true;
                    }
                    else if ((element != opts.optionalmarker.start &amp;&amp; element != opts.optionalmarker.end) || escaped) {
                        var maskdef = opts.definitions[element];
                        if (maskdef &amp;&amp; !escaped) {
                            for (var i = 0; i &lt; maskdef.cardinality; i++) {
                                outElem.push(getPlaceHolder(outCount + i));
                            }
                        } else {
                            outElem.push(element);
                            escaped = false;
                        }
                        outCount += outElem.length;
                        return outElem;
                    }
                });

                &#x2F;&#x2F;allocate repetitions
                var repeatedMask = singleMask.slice();
                for (var i = 1; i &lt; opts.repeat &amp;&amp; opts.greedy; i++) {
                    repeatedMask = repeatedMask.concat(singleMask.slice());
                }

                return repeatedMask;
            }

            &#x2F;&#x2F;test definition =&gt; {fn: RegExp&#x2F;function, cardinality: int, optionality: bool, newBlockMarker: bool, offset: int, casing: null&#x2F;upper&#x2F;lower, def: definitionSymbol}
            function getTestingChain() {
                var isOptional = false, escaped = false;
                var newBlockMarker = false; &#x2F;&#x2F;indicates wheter the begin&#x2F;ending of a block should be indicated

                return $.map(opts.mask.split(&quot;&quot;), function (element, index) {
                    var outElem = [];

                    if (element == opts.escapeChar) {
                        escaped = true;
                    } else if (element == opts.optionalmarker.start &amp;&amp; !escaped) {
                        isOptional = true;
                        newBlockMarker = true;
                    }
                    else if (element == opts.optionalmarker.end &amp;&amp; !escaped) {
                        isOptional = false;
                        newBlockMarker = true;
                    }
                    else {
                        var maskdef = opts.definitions[element];
                        if (maskdef &amp;&amp; !escaped) {
                            var prevalidators = maskdef[&quot;prevalidator&quot;], prevalidatorsL = prevalidators ? prevalidators.length : 0;
                            for (var i = 1; i &lt; maskdef.cardinality; i++) {
                                var prevalidator = prevalidatorsL &gt;= i ? prevalidators[i - 1] : [], validator = prevalidator[&quot;validator&quot;], cardinality = prevalidator[&quot;cardinality&quot;];
                                outElem.push({ fn: validator ? typeof validator == &#x27;string&#x27; ? new RegExp(validator) : new function () { this.test = validator; } : new RegExp(&quot;.&quot;), cardinality: cardinality ? cardinality : 1, optionality: isOptional, newBlockMarker: isOptional == true ? newBlockMarker : false, offset: 0, casing: maskdef[&quot;casing&quot;], def: element });
                                if (isOptional == true) &#x2F;&#x2F;reset newBlockMarker
                                    newBlockMarker = false;
                            }
                            outElem.push({ fn: maskdef.validator ? typeof maskdef.validator == &#x27;string&#x27; ? new RegExp(maskdef.validator) : new function () { this.test = maskdef.validator; } : new RegExp(&quot;.&quot;), cardinality: maskdef.cardinality, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: maskdef[&quot;casing&quot;], def: element });
                        } else {
                            outElem.push({ fn: null, cardinality: 0, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: null, def: element });
                            escaped = false;
                        }
                        &#x2F;&#x2F;reset newBlockMarker
                        newBlockMarker = false;
                        return outElem;
                    }
                });
            }

            function isValid(pos, c, buffer, strict) { &#x2F;&#x2F;strict true ~ no correction or autofill
                if (pos &lt; 0 || pos &gt;= getMaskLength()) return false;
                var testPos = determineTestPosition(pos), loopend = c ? 1 : 0, chrs = &#x27;&#x27;;
                for (var i = tests[testPos].cardinality; i &gt; loopend; i--) {
                    chrs += getBufferElement(buffer, testPos - (i - 1));
                }

                if (c) { chrs += c; }
                &#x2F;&#x2F;return is false or a json object =&gt; { pos: ??, c: ??}
                return tests[testPos].fn != null ? tests[testPos].fn.test(chrs, buffer, pos, strict, opts) : false;
            }

            function isMask(pos) {
                var testPos = determineTestPosition(pos);
                var test = tests[testPos];

                return test != undefined ? test.fn : false;
            }

            function determineTestPosition(pos) {
                return pos % tests.length;
            }

            function getPlaceHolder(pos) {
                return opts.placeholder.charAt(pos % opts.placeholder.length);
            }

            function getMaskLength() {
                var calculatedLength = _buffer.length;
                if (!opts.greedy &amp;&amp; opts.repeat &gt; 1) {
                    calculatedLength += (_buffer.length * (opts.repeat - 1));
                }
                return calculatedLength;
            }

            &#x2F;&#x2F;pos: from position
            function seekNext(buffer, pos) {
                var maskL = getMaskLength();
                if (pos &gt;= maskL) return maskL;
                var position = pos;
                while (++position &lt; maskL &amp;&amp; !isMask(position)) { };
                return position;
            }
            &#x2F;&#x2F;pos: from position
            function seekPrevious(buffer, pos) {
                var position = pos;
                if (position &lt;= 0) return 0;

                while (--position &gt; 0 &amp;&amp; !isMask(position)) { };
                return position;
            }

            function setBufferElement(buffer, position, element) {
                &#x2F;&#x2F;position = prepareBuffer(buffer, position);

                var test = tests[determineTestPosition(position)];
                var elem = element;
                if (elem != undefined) {
                    switch (test.casing) {
                        case &quot;upper&quot;:
                            elem = element.toUpperCase();
                            break;
                        case &quot;lower&quot;:
                            elem = element.toLowerCase();
                            break;
                    }
                }

                buffer[position] = elem;
            }
            function getBufferElement(buffer, position, autoPrepare) {
                if (autoPrepare) position = prepareBuffer(buffer, position);
                return buffer[position];
            }

            &#x2F;&#x2F;needed to handle the non-greedy mask repetitions
            function prepareBuffer(buffer, position, isRTL) {
                var j;
                if (isRTL) {
                    while (position &lt; 0 &amp;&amp; buffer.length &lt; getMaskLength()) {
                        j = _buffer.length - 1;
                        position = _buffer.length;
                        while (_buffer[j] !== undefined) {
                            buffer.unshift(_buffer[j--]);
                        }
                    }
                } else {
                    while (buffer[position] == undefined &amp;&amp; buffer.length &lt; getMaskLength()) {
                        j = 0;
                        while (_buffer[j] !== undefined) { &#x2F;&#x2F;add a new buffer
                            buffer.push(_buffer[j++]);
                        }
                    }
                }

                return position;
            }

            function writeBuffer(input, buffer, caretPos) {
                input._valueSet(buffer.join(&#x27;&#x27;));
                if (caretPos != undefined) {
                    if (android) {
                        setTimeout(function () {
                            caret(input, caretPos);
                        }, 100);
                    }
                    else caret(input, caretPos);
                }
            };
            function clearBuffer(buffer, start, end) {
                for (var i = start, maskL = getMaskLength(); i &lt; end &amp;&amp; i &lt; maskL; i++) {
                    setBufferElement(buffer, i, getBufferElement(_buffer.slice(), i));
                }
            };

            function setReTargetPlaceHolder(buffer, pos) {
                var testPos = determineTestPosition(pos);
                setBufferElement(buffer, pos, getBufferElement(_buffer, testPos));
            }

            function checkVal(input, buffer, clearInvalid, skipRadixHandling) {
                var isRTL = $(input).data(&#x27;inputmask&#x27;)[&#x27;isRTL&#x27;],
                    inputValue = truncateInput(input._valueGet(), isRTL).split(&#x27;&#x27;);

                if (isRTL) { &#x2F;&#x2F;align inputValue for RTL&#x2F;numeric input
                    var maskL = getMaskLength();
                    var inputValueRev = inputValue.reverse(); inputValueRev.length = maskL;

                    for (var i = 0; i &lt; maskL; i++) {
                        var targetPosition = determineTestPosition(maskL - (i + 1));
                        if (tests[targetPosition].fn == null &amp;&amp; inputValueRev[i] != getBufferElement(_buffer, targetPosition)) {
                            inputValueRev.splice(i, 0, getBufferElement(_buffer, targetPosition));
                            inputValueRev.length = maskL;
                        } else {
                            inputValueRev[i] = inputValueRev[i] || getBufferElement(_buffer, targetPosition);
                        }
                    }
                    inputValue = inputValueRev.reverse();
                }
                clearBuffer(buffer, 0, buffer.length);
                buffer.length = _buffer.length;
                var lastMatch = -1, checkPosition = -1, np, maskL = getMaskLength(), ivl = inputValue.length, rtlMatch = ivl == 0 ? maskL : -1;
                for (var i = 0; i &lt; ivl; i++) {
                    for (var pos = checkPosition + 1; pos &lt; maskL; pos++) {
                        if (isMask(pos)) {
                            var c = inputValue[i];
                            if ((np = isValid(pos, c, buffer, !clearInvalid)) !== false) {
                                if (np !== true) {
                                    pos = np.pos || pos; &#x2F;&#x2F;set new position from isValid
                                    c = np.c || c; &#x2F;&#x2F;set new char from isValid
                                }
                                setBufferElement(buffer, pos, c);
                                lastMatch = checkPosition = pos;
                            } else {
                                setReTargetPlaceHolder(buffer, pos);
                                if (c == getPlaceHolder(pos)) {
                                    checkPosition = pos;
                                    rtlMatch = pos;
                                }
                            }
                            break;
                        } else {   &#x2F;&#x2F;nonmask
                            setReTargetPlaceHolder(buffer, pos);
                            if (lastMatch == checkPosition) &#x2F;&#x2F;once outsync the nonmask cannot be the lastmatch
                                lastMatch = pos;
                            checkPosition = pos;
                            if (inputValue[i] == getBufferElement(buffer, pos))
                                break;
                        }
                    }
                }
                &#x2F;&#x2F;Truncate buffer when using non-greedy masks
                if (opts.greedy == false) {
                    var newBuffer = truncateInput(buffer.join(&#x27;&#x27;), isRTL).split(&#x27;&#x27;);
                    while (buffer.length != newBuffer.length) {  &#x2F;&#x2F;map changes into the original buffer
                        isRTL ? buffer.shift() : buffer.pop();
                    }
                }

                if (clearInvalid) {
                    writeBuffer(input, buffer);
                }
                return isRTL ? (opts.numericInput ? ($.inArray(opts.radixPoint, buffer) != -1 &amp;&amp; skipRadixHandling !== true ? $.inArray(opts.radixPoint, buffer) : seekNext(buffer, maskL)) : seekNext(buffer, rtlMatch)) : seekNext(buffer, lastMatch);
            }

            function escapeRegex(str) {
                var specials = [&#x27;&#x2F;&#x27;, &#x27;.&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;?&#x27;, &#x27;|&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;\\&#x27;];
                return str.replace(new RegExp(&#x27;(\\&#x27; + specials.join(&#x27;|\\&#x27;) + &#x27;)&#x27;, &#x27;gim&#x27;), &#x27;\\$1&#x27;);
            }
            function truncateInput(inputValue, rtl) {
                return rtl ? inputValue.replace(new RegExp(&quot;^(&quot; + escapeRegex(_buffer.join(&#x27;&#x27;)) + &quot;)*&quot;), &quot;&quot;) : inputValue.replace(new RegExp(&quot;(&quot; + escapeRegex(_buffer.join(&#x27;&#x27;)) + &quot;)*$&quot;), &quot;&quot;);
            }

            function clearOptionalTail(input, buffer) {
                checkVal(input, buffer, false);
                var tmpBuffer = buffer.slice();
                if ($(input).data(&#x27;inputmask&#x27;)[&#x27;isRTL&#x27;]) {
                    for (var pos = 0; pos &lt;= tmpBuffer.length - 1; pos++) {
                        var testPos = determineTestPosition(pos);
                        if (tests[testPos].optionality) {
                            if (getPlaceHolder(pos) == buffer[pos] || !isMask(pos))
                                tmpBuffer.splice(0, 1);
                            else break;
                        } else break;
                    }
                } else {
                    for (var pos = tmpBuffer.length - 1; pos &gt;= 0; pos--) {
                        var testPos = determineTestPosition(pos);
                        if (tests[testPos].optionality) {
                            if (getPlaceHolder(pos) == buffer[pos] || !isMask(pos))
                                tmpBuffer.pop();
                            else break;
                        } else break;
                    }
                }
                writeBuffer(input, tmpBuffer);
            }

            &#x2F;&#x2F;functionality fn
            function unmaskedvalue($input, skipDatepickerCheck) {
                var input = $input[0];
                if (tests &amp;&amp; (skipDatepickerCheck === true || !$input.hasClass(&#x27;hasDatepicker&#x27;))) {
                    var buffer = _buffer.slice();
                    checkVal(input, buffer);
                    return $.map(buffer, function (element, index) {
                        return isMask(index) &amp;&amp; element != getBufferElement(_buffer.slice(), index) ? element : null;
                    }).join(&#x27;&#x27;);
                }
                else {
                    return input._valueGet();
                }
            }

            function caret(input, begin, end) {
                var npt = input.jquery &amp;&amp; input.length &gt; 0 ? input[0] : input;
                if (typeof begin == &#x27;number&#x27;) {
                    end = (typeof end == &#x27;number&#x27;) ? end : begin;
                    if (opts.insertMode == false &amp;&amp; begin == end) end++; &#x2F;&#x2F;set visualization for insert&#x2F;overwrite mode
                    if (npt.setSelectionRange) {
                        npt.setSelectionRange(begin, end);
                    } else if (npt.createTextRange) {
                        var range = npt.createTextRange();
                        range.collapse(true);
                        range.moveEnd(&#x27;character&#x27;, end);
                        range.moveStart(&#x27;character&#x27;, begin);
                        range.select();
                    }
                    npt.focus();
                    if (android &amp;&amp; end != npt.selectionEnd) caretposCorrection = { begin: begin, end: end };
                } else {
                    var caretpos = android ? caretposCorrection : null, caretposCorrection = null;
                    if (caretpos == null) {
                        if (npt.setSelectionRange) {
                            begin = npt.selectionStart;
                            end = npt.selectionEnd;
                        } else if (document.selection &amp;&amp; document.selection.createRange) {
                            var range = document.selection.createRange();
                            begin = 0 - range.duplicate().moveStart(&#x27;character&#x27;, -100000);
                            end = begin + range.text.length;
                        }
                        caretpos = { begin: begin, end: end };
                    }
                    return caretpos;
                }
            };

            function mask(el) {
                var $input = $(el);
                if (!$input.is(&quot;:input&quot;)) return;

                &#x2F;&#x2F;correct greedy setting if needed
                opts.greedy = opts.greedy ? opts.greedy : opts.repeat == 0;

                &#x2F;&#x2F;handle maxlength attribute
                var maxLength = $input.prop(&#x27;maxLength&#x27;);
                if (getMaskLength() &gt; maxLength &amp;&amp; maxLength &gt; -1) { &#x2F;&#x2F;FF sets no defined max length to -1 
                    if (maxLength &lt; _buffer.length) _buffer.length = maxLength;
                    if (opts.greedy == false) {
                        opts.repeat = Math.round(maxLength &#x2F; _buffer.length);
                    }
                }
                $input.prop(&#x27;maxLength&#x27;, getMaskLength() * 2);

                &#x2F;&#x2F;store tests &amp; original buffer in the input element - used to get the unmasked value
                $input.data(&#x27;inputmask&#x27;, {
                    &#x27;tests&#x27;: tests,
                    &#x27;_buffer&#x27;: _buffer,
                    &#x27;greedy&#x27;: opts.greedy,
                    &#x27;repeat&#x27;: opts.repeat,
                    &#x27;autoUnmask&#x27;: opts.autoUnmask,
                    &#x27;definitions&#x27;: opts.definitions,
                    &#x27;isRTL&#x27;: false
                });

                patchValueProperty(el);

                &#x2F;&#x2F;init vars
                var buffer = _buffer.slice(),
                undoBuffer = el._valueGet(),
                skipKeyPressEvent = false, &#x2F;&#x2F;Safari 5.1.x - modal dialog fires keypress twice workaround
                ignorable = false,
                lastPosition = -1,
                firstMaskPos = seekNext(buffer, -1),
                lastMaskPos = seekPrevious(buffer, getMaskLength()),
                isRTL = false;
                if (el.dir == &quot;rtl&quot; || opts.numericInput) {
                    el.dir = &quot;ltr&quot;
                    $input.css(&quot;text-align&quot;, &quot;right&quot;);
                    $input.removeAttr(&quot;dir&quot;);
                    var inputData = $input.data(&#x27;inputmask&#x27;);
                    inputData[&#x27;isRTL&#x27;] = true;
                    $input.data(&#x27;inputmask&#x27;, inputData);
                    isRTL = true;
                }

                &#x2F;&#x2F;unbind all events - to make sure that no other mask will interfere when re-masking
                $input.unbind(&quot;.inputmask&quot;);
                $input.removeClass(&#x27;focus.inputmask&#x27;);
                &#x2F;&#x2F;bind events
                $input.bind(&quot;mouseenter.inputmask&quot;, function () {
                    var $input = $(this), input = this;
                    if (!$input.hasClass(&#x27;focus.inputmask&#x27;)) {
                        var nptL = input._valueGet().length;
                        if (nptL == 0) {
                            buffer = _buffer.slice();
                            writeBuffer(input, buffer);
                        } else if (nptL &lt; buffer.length)
                            writeBuffer(input, buffer);
                    }
                }).bind(&quot;blur.inputmask&quot;, function () {
                    var $input = $(this), input = this, nptValue = input._valueGet();
                    $input.removeClass(&#x27;focus.inputmask&#x27;);
                    if (nptValue != undoBuffer) {
                        $input.change();
                    }
                    if (opts.clearMaskOnLostFocus) {
                        if (nptValue == _buffer.join(&#x27;&#x27;))
                            input._valueSet(&#x27;&#x27;);
                        else { &#x2F;&#x2F;clearout optional tail of the mask
                            clearOptionalTail(input, buffer);
                        }
                    }
                    if ((opts.clearIncomplete || opts.onincomplete) &amp;&amp; !isComplete(input)) {
                        if (opts.onincomplete) {
                            opts.onincomplete.call(input);
                        }
                        if (opts.clearIncomplete) {
                            if (opts.clearMaskOnLostFocus)
                                input._valueSet(&#x27;&#x27;);
                            else {
                                buffer = _buffer.slice();
                                writeBuffer(input, buffer);
                            }
                        }
                    }
                }).bind(&quot;focus.inputmask&quot;, function () {
                    var $input = $(this), input = this;
                    $input.addClass(&#x27;focus.inputmask&#x27;);
                    undoBuffer = input._valueGet();
                }).bind(&quot;mouseleave.inputmask&quot;, function () {
                    var $input = $(this), input = this;
                    if (opts.clearMaskOnLostFocus) {
                        if (!$input.hasClass(&#x27;focus.inputmask&#x27;)) {
                            if (input._valueGet() == _buffer.join(&#x27;&#x27;))
                                input._valueSet(&#x27;&#x27;);
                            else { &#x2F;&#x2F;clearout optional tail of the mask
                                clearOptionalTail(input, buffer);
                            }
                        }
                    }
                }).bind(&quot;click.inputmask&quot;, function () {
                    var input = this;
                    setTimeout(function () {
                        var selectedCaret = caret(input);
                        if (selectedCaret.begin == selectedCaret.end) {
                            var clickPosition = selectedCaret.begin;
                            lastPosition = checkVal(input, buffer, false);
                            if (isRTL)
                                caret(input, clickPosition &gt; lastPosition &amp;&amp; (isValid(clickPosition, buffer[clickPosition], buffer, true) !== false || !isMask(clickPosition)) ? clickPosition : lastPosition);
                            else
                                caret(input, clickPosition &lt; lastPosition &amp;&amp; (isValid(clickPosition, buffer[clickPosition], buffer, true) !== false || !isMask(clickPosition)) ? clickPosition : lastPosition);
                        }
                    }, 0);
                }).bind(&#x27;dblclick.inputmask&#x27;, function () {
                    var input = this;
                    setTimeout(function () {
                        caret(input, 0, lastPosition);
                    }, 0);
                }).bind(&quot;keydown.inputmask&quot;, keydownEvent
                ).bind(&quot;keypress.inputmask&quot;, keypressEvent
                ).bind(&quot;keyup.inputmask&quot;, keyupEvent
                ).bind(pasteEvent + &quot;.inputmask, dragdrop.inputmask, drop.inputmask&quot;, function () {
                    var input = this;
                    setTimeout(function () {
                        caret(input, checkVal(input, buffer, true));
                    }, 0);
                }).bind(&#x27;setvalue.inputmask&#x27;, function () {
                    var input = this;
                    undoBuffer = input._valueGet();
                    checkVal(input, buffer, true);
                    if (input._valueGet() == _buffer.join(&#x27;&#x27;))
                        input._valueSet(&#x27;&#x27;);
                });

                &#x2F;&#x2F;apply mask
                lastPosition = checkVal(el, buffer, true);
                if (document.activeElement === el) { &#x2F;&#x2F;position the caret when in focus
                    $input.addClass(&#x27;focus.inputmask&#x27;);
                    caret(el, lastPosition);
                } else if (opts.clearMaskOnLostFocus &amp;&amp; el._valueGet() == _buffer.join(&#x27;&#x27;))
                    el._valueSet(&#x27;&#x27;);

                installEventRuler(el);

                &#x2F;&#x2F;private functions
                function isComplete(npt) {
                    var complete = true, nptValue = npt._valueGet(), ml = nptValue.length;
                    for (var i = 0; i &lt; ml; i++) {
                        if (isMask(i) &amp;&amp; nptValue.charAt(i) == getPlaceHolder(i)) {
                            complete = false;
                            break;
                        }
                    }
                    return complete;
                }


                function installEventRuler(npt) {
                    var events = $._data(npt).events;

                    $.each(events, function (eventType, eventHandlers) {
                        $(npt).bind(eventType + &quot;.inputmask&quot;, function (event) {
                            if (this.readOnly || this.disabled) {
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                                event.preventDefault();
                                return false;
                            }
                        });
                        &#x2F;&#x2F;!! the bound handlers are executed in the order they where bound
                        &#x2F;&#x2F;reorder the events
                        var ourHandler = eventHandlers[eventHandlers.length - 1];
                        for (var i = eventHandlers.length - 1; i &gt; 0; i--) {
                            eventHandlers[i] = eventHandlers[i - 1];
                        }
                        eventHandlers[0] = ourHandler;
                    });
                }

                function patchValueProperty(npt) {
                    var valueProperty;
                    if (Object.getOwnPropertyDescriptor)
                        valueProperty = Object.getOwnPropertyDescriptor(npt, &quot;value&quot;);
                    if (valueProperty &amp;&amp; valueProperty.get) {
                        if (!npt._valueGet) {

                            npt._valueGet = valueProperty.get;
                            npt._valueSet = valueProperty.set;

                            Object.defineProperty(npt, &quot;value&quot;, {
                                get: function () {
                                    var $self = $(this), inputData = $(this).data(&#x27;inputmask&#x27;);
                                    return inputData &amp;&amp; inputData[&#x27;autoUnmask&#x27;] ? $self.inputmask(&#x27;unmaskedvalue&#x27;) : this._valueGet() != inputData[&#x27;_buffer&#x27;].join(&#x27;&#x27;) ? this._valueGet() : &#x27;&#x27;;
                                },
                                set: function (value) {
                                    this._valueSet(value); $(this).triggerHandler(&#x27;setvalue.inputmask&#x27;);
                                }
                            });
                        }
                    } else if (document.__lookupGetter__ &amp;&amp; npt.__lookupGetter__(&quot;value&quot;)) {
                        if (!npt._valueGet) {
                            npt._valueGet = npt.__lookupGetter__(&quot;value&quot;);
                            npt._valueSet = npt.__lookupSetter__(&quot;value&quot;);

                            npt.__defineGetter__(&quot;value&quot;, function () {
                                var $self = $(this), inputData = $(this).data(&#x27;inputmask&#x27;);
                                return inputData &amp;&amp; inputData[&#x27;autoUnmask&#x27;] ? $self.inputmask(&#x27;unmaskedvalue&#x27;) : this._valueGet() != inputData[&#x27;_buffer&#x27;].join(&#x27;&#x27;) ? this._valueGet() : &#x27;&#x27;;
                            });
                            npt.__defineSetter__(&quot;value&quot;, function (value) {
                                this._valueSet(value); $(this).triggerHandler(&#x27;setvalue.inputmask&#x27;);
                            });
                        }
                    } else {
                        if (!npt._valueGet) {
                            npt._valueGet = function () { return this.value; }
                            npt._valueSet = function (value) { this.value = value; }
                        }
                        if ($.fn.val.inputmaskpatch != true) {
                            $.fn.val = function () {
                                if (arguments.length == 0) {
                                    var $self = $(this);
                                    if ($self.data(&#x27;inputmask&#x27;)) {
                                        if ($self.data(&#x27;inputmask&#x27;)[&#x27;autoUnmask&#x27;])
                                            return $self.inputmask(&#x27;unmaskedvalue&#x27;);
                                        else {
                                            var result = $.inputmask.val.apply($self);
                                            return result != $self.data(&#x27;inputmask&#x27;)[&#x27;_buffer&#x27;].join(&#x27;&#x27;) ? result : &#x27;&#x27;;
                                        }
                                    } else return $.inputmask.val.apply($self);
                                } else {
                                    var args = arguments;
                                    return this.each(function () {
                                        var $self = $(this);
                                        var result = $.inputmask.val.apply($self, args);
                                        if ($self.data(&#x27;inputmask&#x27;)) $self.triggerHandler(&#x27;setvalue.inputmask&#x27;);
                                        return result;
                                    });
                                }
                            };
                            $.extend($.fn.val, {
                                inputmaskpatch: true
                            });
                        }
                    }
                }
                &#x2F;&#x2F;shift chars to left from start to end and put c at end position if defined
                function shiftL(start, end, c) {
                    while (!isMask(start) &amp;&amp; start - 1 &gt;= 0) start--;
                    for (var i = start; i &lt; end &amp;&amp; i &lt; getMaskLength(); i++) {
                        if (isMask(i)) {
                            setReTargetPlaceHolder(buffer, i);
                            var j = seekNext(buffer, i);
                            var p = getBufferElement(buffer, j);
                            if (p != getPlaceHolder(j)) {
                                if (j &lt; getMaskLength() &amp;&amp; isValid(i, p, buffer, true) !== false &amp;&amp; tests[determineTestPosition(i)].def == tests[determineTestPosition(j)].def) {
                                    setBufferElement(buffer, i, getBufferElement(buffer, j));
                                    setReTargetPlaceHolder(buffer, j); &#x2F;&#x2F;cleanup next position
                                } else {
                                    if (isMask(i))
                                        break;
                                }
                            } else if (c == undefined) break;
                        } else {
                            setReTargetPlaceHolder(buffer, i);
                        }
                    }
                    if (c != undefined)
                        setBufferElement(buffer, isRTL ? end : seekPrevious(buffer, end), c);

                    buffer = truncateInput(buffer.join(&#x27;&#x27;), isRTL).split(&#x27;&#x27;);
                    if (buffer.length == 0) buffer = _buffer.slice();

                    return start; &#x2F;&#x2F;return the used start position
                }
                function shiftR(start, end, c, full) { &#x2F;&#x2F;full =&gt; behave like a push right ~ do not stop on placeholders
                    for (var i = start; i &lt;= end &amp;&amp; i &lt; getMaskLength(); i++) {
                        if (isMask(i)) {
                            var t = getBufferElement(buffer, i);
                            setBufferElement(buffer, i, c);
                            if (t != getPlaceHolder(i)) {
                                var j = seekNext(buffer, i);
                                if (j &lt; getMaskLength()) {
                                    if (isValid(j, t, buffer, true) !== false &amp;&amp; tests[determineTestPosition(i)].def == tests[determineTestPosition(j)].def)
                                        c = t;
                                    else {
                                        if (isMask(j))
                                            break;
                                        else c = t;
                                    }
                                } else break;
                            } else if (full !== true) break;
                        } else
                            setReTargetPlaceHolder(buffer, i);
                    }
                    var lengthBefore = buffer.length;
                    buffer = truncateInput(buffer.join(&#x27;&#x27;), isRTL).split(&#x27;&#x27;);
                    if (buffer.length == 0) buffer = _buffer.slice();

                    return end - (lengthBefore - buffer.length);  &#x2F;&#x2F;return new start position
                };

                function keydownEvent(e) {
                    &#x2F;&#x2F;Safari 5.1.x - modal dialog fires keypress twice workaround
                    skipKeyPressEvent = false;

                    var input = this, k = e.keyCode, pos = caret(input);

                    &#x2F;&#x2F;set input direction according the position to the radixPoint
                    if (opts.numericInput) {
                        var nptStr = input._valueGet();
                        var radixPosition = $.inArray(opts.radixPoint, nptStr);
                        if (radixPosition != -1) {
                            isRTL = pos.begin &lt;= radixPosition || pos.end &lt;= radixPosition;
                        }
                    }

                    &#x2F;&#x2F;backspace, delete, and escape get special treatment
                    if (k == opts.keyCode.BACKSPACE || k == opts.keyCode.DELETE || (iphone &amp;&amp; k == 127)) {&#x2F;&#x2F;backspace&#x2F;delete
                        var maskL = getMaskLength();
                        if (pos.begin == 0 &amp;&amp; pos.end == maskL) {
                            buffer = _buffer.slice();
                            writeBuffer(input, buffer);
                            caret(input, checkVal(input, buffer, false));
                        } else if ((pos.end - pos.begin) &gt; 1 || ((pos.end - pos.begin) == 1 &amp;&amp; opts.insertMode)) {
                            clearBuffer(buffer, pos.begin, pos.end);
                            writeBuffer(input, buffer, isRTL ? checkVal(input, buffer, false) : pos.begin);
                        } else {
                            var beginPos = pos.begin - (k == opts.keyCode.DELETE ? 0 : 1);
                            if (beginPos &lt; firstMaskPos &amp;&amp; k == opts.keyCode.DELETE) {
                                beginPos = firstMaskPos;
                            }
                            if (beginPos &gt;= firstMaskPos) {
                                if (opts.numericInput &amp;&amp; opts.greedy &amp;&amp; k == opts.keyCode.DELETE &amp;&amp; buffer[beginPos] == opts.radixPoint) {
                                    beginPos = seekNext(buffer, beginPos);
                                    isRTL = false;
                                }
                                if (isRTL) {
                                    beginPos = shiftR(firstMaskPos, beginPos, getPlaceHolder(beginPos), true);
                                    beginPos = (opts.numericInput &amp;&amp; opts.greedy &amp;&amp; k == opts.keyCode.BACKSPACE &amp;&amp; buffer[beginPos + 1] == opts.radixPoint) ? beginPos + 1 : seekNext(buffer, beginPos);
                                } else beginPos = shiftL(beginPos, maskL);
                                writeBuffer(input, buffer, beginPos);
                            }
                        }
                        if (opts.oncleared &amp;&amp; input._valueGet() == _buffer.join(&#x27;&#x27;))
                            opts.oncleared.call(input);

                        return false;
                    } else if (k == opts.keyCode.END || k == opts.keyCode.PAGE_DOWN) { &#x2F;&#x2F;when END or PAGE_DOWN pressed set position at lastmatch
                        setTimeout(function () {
                            var caretPos = checkVal(input, buffer, false, true);
                            if (!opts.insertMode &amp;&amp; caretPos == getMaskLength() &amp;&amp; !e.shiftKey) caretPos--;
                            caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);
                        }, 0);
                        return false;
                    } else if (k == opts.keyCode.HOME || k == opts.keyCode.PAGE_UP) {&#x2F;&#x2F;Home or page_up
                        caret(input, 0, e.shiftKey ? pos.begin : 0);
                        return false;
                    }
                    else if (k == opts.keyCode.ESCAPE) {&#x2F;&#x2F;escape
                        input._valueSet(undoBuffer);
                        caret(input, 0, checkVal(input, buffer));
                        return false;
                    } else if (k == opts.keyCode.INSERT) {&#x2F;&#x2F;insert
                        opts.insertMode = !opts.insertMode;
                        caret(input, !opts.insertMode &amp;&amp; pos.begin == getMaskLength() ? pos.begin - 1 : pos.begin);
                        return false;
                    } else if (e.ctrlKey &amp;&amp; k == 88) {
                        setTimeout(function () {
                            caret(input, checkVal(input, buffer, true));
                        }, 0);
                    } else if (!opts.insertMode) { &#x2F;&#x2F;overwritemode
                        if (k == opts.keyCode.RIGHT) {&#x2F;&#x2F;right
                            var caretPos = pos.begin == pos.end ? pos.end + 1 : pos.end;
                            caretPos = caretPos &lt; getMaskLength() ? caretPos : pos.end;
                            caret(input, e.shiftKey ? pos.begin : caretPos, e.shiftKey ? caretPos + 1 : caretPos);
                            return false;
                        } else if (k == opts.keyCode.LEFT) {&#x2F;&#x2F;left
                            var caretPos = pos.begin - 1;
                            caretPos = caretPos &gt; 0 ? caretPos : 0;
                            caret(input, caretPos, e.shiftKey ? pos.end : caretPos);
                            return false;
                        }
                    }

                    opts.onKeyDown.call(this, e, opts); &#x2F;&#x2F;extra stuff to execute on keydown
                    ignorable = $.inArray(k, opts.ignorables) != -1;
                }

                function keypressEvent(e) {
                    &#x2F;&#x2F;Safari 5.1.x - modal dialog fires keypress twice workaround
                    if (skipKeyPressEvent) return false;
                    skipKeyPressEvent = true;

                    var input = this;

                    e = e || window.event;
                    var k = e.which || e.charCode || e.keyCode;

                    if (opts.numericInput &amp;&amp; k == opts.radixPoint.charCodeAt(opts.radixPoint.length - 1)) {
                        var nptStr = input._valueGet();
                        var radixPosition = $.inArray(opts.radixPoint, nptStr);
                        caret(input, seekNext(buffer, radixPosition != -1 ? radixPosition : getMaskLength()));
                    }

                    if (e.ctrlKey || e.altKey || e.metaKey || ignorable) {&#x2F;&#x2F;Ignore
                        return true;
                    } else {
                        if (k) {
                            var pos = caret(input), c = String.fromCharCode(k), maskL = getMaskLength();
                            clearBuffer(buffer, pos.begin, pos.end);

                            if (isRTL) {
                                var p = opts.numericInput ? pos.end : seekPrevious(buffer, pos.end), np;
                                if ((np = isValid(p == maskL || getBufferElement(buffer, p) == opts.radixPoint ? seekPrevious(buffer, p) : p, c, buffer, false)) !== false) {
                                    if (np !== true) {
                                        p = np.pos || pos; &#x2F;&#x2F;set new position from isValid
                                        c = np.c || c; &#x2F;&#x2F;set new char from isValid
                                    }

                                    var firstUnmaskedPosition = firstMaskPos;
                                    if (opts.insertMode == true) {
                                        if (opts.greedy == true) {
                                            var bfrClone = buffer.slice();
                                            while (getBufferElement(bfrClone, firstUnmaskedPosition, true) != getPlaceHolder(firstUnmaskedPosition) &amp;&amp; firstUnmaskedPosition &lt;= p) {
                                                firstUnmaskedPosition = seekNext(buffer, firstUnmaskedPosition);
                                            }
                                        }

                                        if (firstUnmaskedPosition &lt;= p &amp;&amp; (opts.greedy || buffer.length &lt; maskL)) {
                                            if (buffer[firstMaskPos] != getPlaceHolder(firstMaskPos) &amp;&amp; buffer.length &lt; maskL) {
                                                var offset = prepareBuffer(buffer, -1, isRTL);
                                                if (pos.end != 0) p = p + offset;
                                                maskL = buffer.length;
                                            }
                                            shiftL(firstUnmaskedPosition, opts.numericInput ? seekPrevious(buffer, p) : p, c);
                                        } else return false;
                                    } else setBufferElement(buffer, opts.numericInput ? seekPrevious(buffer, p) : p, c);
                                    writeBuffer(input, buffer, opts.numericInput &amp;&amp; p == 0 ? seekNext(buffer, p) : p);
                                    if (opts.oncomplete &amp;&amp; isComplete(input))
                                        opts.oncomplete.call(input);
                                } else if (android) writeBuffer(input, buffer, pos.begin);
                            }
                            else {
                                var p = seekNext(buffer, pos.begin - 1), np;
                                prepareBuffer(buffer, p, isRTL);
                                if ((np = isValid(p, c, buffer, false)) !== false) {
                                    if (np !== true) {
                                        p = np.pos || p; &#x2F;&#x2F;set new position from isValid
                                        c = np.c || c; &#x2F;&#x2F;set new char from isValid
                                    }
                                    if (opts.insertMode == true) {
                                        var lastUnmaskedPosition = getMaskLength();
                                        var bfrClone = buffer.slice();
                                        while (getBufferElement(bfrClone, lastUnmaskedPosition, true) != getPlaceHolder(lastUnmaskedPosition) &amp;&amp; lastUnmaskedPosition &gt;= p) {
                                            lastUnmaskedPosition = lastUnmaskedPosition == 0 ? -1 : seekPrevious(buffer, lastUnmaskedPosition);
                                        }
                                        if (lastUnmaskedPosition &gt;= p)
                                            shiftR(p, buffer.length, c);
                                        else return false;
                                    }
                                    else setBufferElement(buffer, p, c);
                                    var next = seekNext(buffer, p);
                                    writeBuffer(input, buffer, next);

                                    if (opts.oncomplete &amp;&amp; isComplete(input))
                                        opts.oncomplete.call(input);
                                } else if (android) writeBuffer(input, buffer, pos.begin);
                            }
                            return false;
                        }
                    }
                }

                function keyupEvent(e) {
                    var $input = $(this), input = this;
                    var k = e.keyCode;
                    opts.onKeyUp.call(this, e, opts); &#x2F;&#x2F;extra stuff to execute on keyup
                    if (k == opts.keyCode.TAB &amp;&amp; $input.hasClass(&#x27;focus.inputmask&#x27;) &amp;&amp; input._valueGet().length == 0) {
                        buffer = _buffer.slice();
                        writeBuffer(input, buffer);
                        if (!isRTL) caret(input, 0);
                        undoBuffer = input._valueGet();
                    }
                }
            }
        };
    }
})(jQuery);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
